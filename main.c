#pragma config(Sensor, in1,    powerExpander,  sensorNone)
#pragma config(Sensor, in2,    mogoLeft,       sensorPotentiometer)
#pragma config(Sensor, in3,    mogoRight,      sensorPotentiometer)
#pragma config(Sensor, dgtl3,  leftDrive,      sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightDrive,     sensorQuadEncoder)
#pragma config(Motor,  port2,           mogoLeft,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           mogoRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           driveFrontLeft, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port5,           driveFrontRight, tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port6,           driveBackLeftA, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port7,           driveBackRightA, tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port8,           driveBackLeftB, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port9,           driveBackRightB, tmotorVex393_MC29, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
 * main.c - Entry point for our codebase
 * The structure of the project is as follows:
 *
 * lib/
 *   hal.c - Hardware Abstraction Layer
 *   lcd.c - LCD Library
 *   motor.c - Motor Algorithmns
 *   pid.c - General purpose PID (Super simple, basically just makes the calculation)
 *   rerun.c - Contains code for the rerun system
 * routines/
 *   auton.c - Routines for the 15-second autonomous
 *   skills.c - Routines for the 60-second programming skills
 *
 **/

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"

#include "lib\util.c"
#include "lib\rerun.c"
#include "lib\hal.c"
#include "routines\auton.c"
#include "routines\skills.c"

#include "lib\lcd.c"

void pre_auton() {
  bStopTasksBetweenModes = true;
  lcdStartup();
  robotConfigure();
}

task autonomous() {
  driveReset();
  startTask(handleAll);
  if (match.type == 0) {
    goAuton(match.routine);
  } else if (match.type == 2) {
    goSkills(match.routine);
  }
}


task debugValues() {
    while(true) {
    	lcdClear();
    	string out;

    	sprintf(out, "%d:%d", SensorValue[leftDrive], SensorValue[rightDrive]);
    	displayLCDString(0, 0, out);


      float multiplier = profileJerk(0, 1500, SensorValue[leftDrive], 0.3);

    	string out2;
    	sprintf(out2, "%d=>%f", SensorValue[leftDrive], multiplier);
    	displayLCDString(1, 0, out2);
    	wait1Msec(60);
    }
}


task usercontrol() {
  driveReset();
  startTask(handleAll);
  startTask(debugValues);

  while (true) {

    updateState();

    if (match.type == 3) {
      outputStateCode();
    }
    wait1Msec(20);
  }
}
