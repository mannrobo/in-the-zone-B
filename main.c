#pragma config(Sensor, in1,    powerExpander,  sensorNone)
#pragma config(Sensor, in2,    mogoLeft,       sensorPotentiometer)
#pragma config(Sensor, in3,    mogoRight,      sensorPotentiometer)
#pragma config(Sensor, dgtl3,  leftDrive,      sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightDrive,     sensorQuadEncoder)
#pragma config(Motor,  port2,           mogoLeft,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           mogoRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           driveFrontLeft, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port5,           driveFrontRight, tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port6,           driveBackLeftA, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port7,           driveBackRightA, tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port8,           driveBackLeftB, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port9,           driveBackRightB, tmotorVex393_MC29, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
 * main.c - Entry point for our codebase
 * The structure of the project is as follows:
 *
 * lib/
 *   hal.c - Hardware Abstraction Layer
 *   lcd.c - LCD Library
 *   motor.c - Motor Algorithmns
 *   pid.c - General purpose PID (Super simple, basically just makes the calculation)
 *   rerun.c - Contains code for the rerun system
 * routines/
 *   auton.c - Routines for the 15-second autonomous
 *   skills.c - Routines for the 60-second programming skills
 *
 **/

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"

#include "lib\util.c"
#include "lib\rerun.c"
#include "lib\hal.c"

#include "routines\auton.c"
#include "routines\skills.c"

#include "lib\lcd.c"

void pre_auton() {
  bStopTasksBetweenModes = false;
  bDisplayCompetitionStatusOnLcd = false;

  startTask(handleAll);
  
  lcdStartup();
  robotConfigure();

  startTask(lcdDebug);
}


task autonomous() {
  writeDebugStreamLine("autonomous()");
  driveReset();
  stopTask(usercontrol);
  if (match.type == 0) {
    goAuton(match.routine);
  } else if (match.type == 2) {
    goSkills(match.routine);
  }
}



task usercontrol() {

  writeDebugStreamLine("usercontrol()");
  driveReset();
  stopTask(autonomous);
  ClearTimer(T1); // Used for rerun

  while (true) {

    // Mogo Lift
    if (vexRT[Btn6U] || vexRT[Btn5U]) robot.mogo = UP;
    if (vexRT[Btn6D] || vexRT[Btn5D]) robot.mogo = DOWN;

    // Drive
    int forward = abs(vexRT[Ch3]) > 60 ? vexRT[Ch3] * 0.8 : 0,
        turn = abs(vexRT[Ch4]) > 90 ? vexRT[Ch4] * 0.4 : 0,
        left = forward + turn,
        right = forward - turn;

    robot.leftDrive  = sgn(left)  * rescaleTo(127, abs(left), abs(right), 0);
    robot.rightDrive = sgn(right) * rescaleTo(127, abs(left), abs(right), 1);

    if (match.type == 3) {
      rerunHandle();
    }

    wait1Msec(20); 
  }
}
