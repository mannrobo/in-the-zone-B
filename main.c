#pragma config(Sensor, in2,    mogoLeft,       sensorPotentiometer)
#pragma config(Sensor, in3,    mogoRight,      sensorPotentiometer)
#pragma config(Sensor, dgtl3,  leftDrive,      sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightDrive,     sensorQuadEncoder)
#pragma config(Motor,  port2,           mogoLeft,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           mogoRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           driveFrontLeft, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port5,           driveFrontRight, tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port6,           driveBackLeftA, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port7,           driveBackRightA, tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port8,           driveBackLeftB, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port9,           driveBackRightB, tmotorVex393_MC29, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
 * main.c - Entry point for our codebase
 * The structure of the project is as follows:
 *
 * lib/
 *   hal.c - Hardware Abstraction Layer
 *   lcd.c - LCD Library
 *   motor.c - Motor Algorithmns
 *   pid.c - General purpose PID (Super simple, basically just makes the calculation)
 *   rerun.c - Contains code for the rerun system
 * routines/
 *   auton.c - Routines for the 15-second autonomous
 *   skills.c - Routines for the 60-second programming skills
 *
 **/

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"

#include "routines\auton.c"
#include "routines\skills.c"

#include "lib\rerun.c"
#include "lib\hal.c"
#include "lib\lcd.c"

void pre_auton() {
  bStopTasksBetweenModes = true;
  lcdStartup();
  robotConfigure();
}

task autonomous() {
  driveReset();
  startTask(handleAll);
  if (match.type == 0) {
    goAuton(match.routine);
  } else if (match.type == 2) {
    goSkills(match.routine);
  }
}


string lineOne;
string lineTwo;
task usercontrol() {
  driveReset();
  startTask(handleAll);
  while (true) {

    updateState();

    if (match.type == 3) {
      outputStateCode();
    }

    lcdClear();
    displayLCDString(0, 0, "Mogo: ");
    sprintf(lineOne, "%d (%d)", SensorValue[mogoLeft], motorTarget[port2]); //Build the value to be displayed
    displayNextLCDString(lineOne);

    outputStateCode();

    wait1Msec(20);
  }
}
